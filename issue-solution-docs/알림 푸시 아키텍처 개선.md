# 알림 푸시 아키텍처 개선

## 문제 상황

### 배경

유튜브 클론 프로젝트는 Spring Boot 멀티모듈 구조로 구성되어 있습니다:

```
프로젝트 구조
├── api 모듈
│   └── 컨트롤러, SSE 등 웹 기술 담당
│
├── notification 모듈
│   └── 알림 도메인 로직 담당
│
└── live-streaming:interaction 모듈
    └── 라이브 스트리밍 도메인 로직 담당
```

도메인별로 컨텍스트를 분리하고, api 모듈이 웹 계층을 담당하는 구조입니다. 도메인 로직(notification, live-streaming)은 웹 기술(api)에 의존하지 않아야 합니다.

**기존 구현**:
- 스트리머가 라이브 방송을 시작하면 구독자들에게 알림을 생성하여 DB에 저장
- 유저가 알림 페이지를 조회하면 저장된 알림을 확인 가능

**새로운 요구사항**:
- 사용자가 페이지를 새로고침하지 않아도 실시간으로 알림을 받을 수 있어야 함
- SSE(Server-Sent Events)를 사용하여 실시간 푸시 기능 구현

### 구현 과정에서 발견된 구조적 문제

실시간 푸시 기능을 추가하기 위해 다음과 같은 흐름이 필요했습니다:

1. `NotificationEventListener`(notification 모듈)에서 알림 생성
2. 생성된 알림을 SSE로 푸시 전송
3. SSE 전송은 `SseEmitterManager`(api 모듈)가 담당

그런데 SSE는 Spring의 웹 기술(`SseEmitter`)을 사용하므로, SSE 관련 컴포넌트는 웹 계층인 api 모듈에 위치해야 합니다. 이로 인해 다음과 같은 의존성 구조가 필요했습니다:

```
[notification 모듈] NotificationEventListener (알림 생성)
  ↓ (SSE 푸시 전송을 위해 직접 의존 필요)
[api 모듈] SseEmitterManager (SSE 연결 관리 및 전송)
```

**문제가 되는 코드**:
```java
// NotificationEventListener.java (notification 모듈)
@Component
@RequiredArgsConstructor
public class NotificationEventListener {
    private final NotificationWriter notificationWriter;
    private final SseEmitterManager sseEmitterManager; // ❌ api 모듈의 SSE 클래스에 직접 의존

    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    @Async
    public void onLiveStreamingStarted(LiveStreamingStartedEvent event) {
        List<Notification> notifications = notificationWriter.write(...);

        // ❌ 도메인 로직이 웹 기술(SSE)에 직접 의존
        notifications.forEach(notification ->
            sseEmitterManager.sendNotification(notification.getReceiver().getId(), notification)
        );
    }
}
```

### 발견된 문제점

1. **DIP(의존성 역전 원칙) 위반**: 핵심 계층이 웹 기술(SSE)을 간접적으로 알게 됩니다
2. **모듈 간 순환 의존성 위험**: notification ↔ api 간 의존 관계 형성이 우려됩니다

## 원인 분석

### 책임의 모호함

"라이브 시작 → 구독자에게 알림을 생성하고 전달한다"는 유스케이스를 하나의 컴포넌트에서 처리하려다 보니 두 가지 책임이 혼재되었습니다:

- **알림 생성**: 핵심 비즈니스 로직 (notification 모듈의 책임)
- **알림 전송**: 전달 메커니즘 (api 모듈의 책임)

### 모듈 배치의 문제

```
notification 모듈 (도메인 로직)
├── NotificationEventListener    → 이벤트 리스너
└── NotificationWriter            → 도메인 로직

api 모듈 (웹 기술)
├── NotificationController        → HTTP 엔드포인트
└── SseEmitterManager             → SSE 연결 관리 및 전송
```

알림 도메인 로직인 NotificationEventListener가 SSE라는 웹 기술에 직접 의존하게 되는 구조입니다.

## 검토한 해결 방안

### 옵션 1: Port/Adapter 패턴

```java
// notification 모듈
public interface NotificationPushPort {
    void push(Notification notification);
}

@Component
public class NotificationEventListener {
    private final NotificationPushPort pushPort; // 인터페이스 의존

    public void onLiveStreamingStarted(...) {
        pushPort.push(notification);
    }
}

// api 모듈
@Component
public class NotificationPushAdapter implements NotificationPushPort {
    @Override
    public void push(Notification notification) {
        // SSE 전송 구현
    }
}
```

**장점**:
- notification 모듈이 인터페이스에만 의존하므로 api 모듈의 구체적인 구현을 알 필요가 없습니다

**단점**:
- 알림 생성과 푸시 전송이 동기적으로 결합됩니다
- 푸시 전송 실패 시 예외 처리가 복잡해집니다

### 옵션 2: 이벤트 기반 분리

```java
// notification 모듈
@Component
public class NotificationEventListener {
    private final ApplicationEventPublisher eventPublisher;

    public void onLiveStreamingStarted(...) {
        List<Notification> notifications = notificationWriter.write(...);

        // 알림 생성 이벤트 발행
        notifications.forEach(notification ->
            eventPublisher.publishEvent(NotificationCreatedEvent.from(notification))
        );
    }
}

// api 모듈
@Component
public class NotificationPushEventListener {
    @EventListener
    public void onNotificationCreated(NotificationCreatedEvent event) {
        // SSE 전송 처리
    }
}
```

**장점**:
- 알림 생성과 전송의 완전한 분리가 가능합니다
- 실패 격리: 푸시 실패가 알림 생성에 영향을 주지 않습니다
- 현재 아키텍처와의 일관성 (LiveStreamingStartedEvent 패턴과 동일)

**단점**:
- 이벤트 흐름 추적이 어려울 수 있습니다
- 구조 복잡도가 증가합니다

## 선택한 해결책: 이벤트 기반 분리

### 선택 이유

#### 현재 아키텍처와의 일관성

프로젝트에서 이미 동일한 패턴을 사용 중이었습니다:

```
LiveStreamingStartedEvent
  → NotificationEventListener (알림 생성)
```

새로운 패턴을 도입하기보다는 기존 패턴을 확장하는 것이 코드베이스 전체의 일관성 유지에 유리하다고 판단했습니다.

#### 실패 격리의 중요성

**알림 생성(핵심 로직)**과 **푸시 전송(부가 기능)**의 성격이 다릅니다:

- 알림 생성은 반드시 성공해야 하는 핵심 비즈니스 로직입니다
- 푸시 전송은 실패하더라도 알림 생성에는 영향을 주지 않아야 하는 부가 기능입니다

이벤트 기반 방식은 이 두 가지의 실패를 구조적으로 격리시킵니다:

```java
// notification 모듈 - 알림 생성
notifications.forEach(notification ->
    eventPublisher.publishEvent(NotificationCreatedEvent.from(notification))
); // 이벤트 발행만 하고 종료

// api 모듈 - 푸시 전송
@EventListener
public void onNotificationCreated(NotificationCreatedEvent event) {
    try {
        sseEmitterManager.send(...);
    } catch (Exception e) {
        // 푸시 실패가 알림 생성에 영향을 주지 않음
    }
}
```

### Port/Adapter를 선택하지 않은 이유

#### 동기적 의존성의 부작용
```java
// Port 방식
notifications.forEach(pushPort::push); // 동기 호출
// 푸시 실패 시 try-catch 필요, 알림 생성 로직과 결합

// Event 방식
eventPublisher.publishEvent(...); // 이벤트 발행 후 종료
// 푸시 실패가 알림 생성에 영향 없음
```

#### 비동기 처리의 자연스러움
- Port도 어차피 비동기 처리가 필요합니다
- 그렇다면 이벤트가 더 자연스러운 비동기 메커니즘입니다

## 개선된 구조

### 최종 아키텍처

```
[LiveStreaming 모듈]
  LiveStreamingStartedEvent 발행
    ↓
[Notification 모듈]
  NotificationEventListener
    - 구독자 조회
    - 알림 생성 (DB 저장)
    - NotificationCreatedEvent 발행
      ↓
[API 모듈]
  NotificationPushEventListener
    - SSE 연결 확인
    - 실시간 푸시 전송
```

### 구현 코드

#### NotificationEventListener (notification 모듈)
```java
@Component
@RequiredArgsConstructor
public class NotificationEventListener {
    private final SubscriptionReader subscriptionReader;
    private final NotificationWriter notificationWriter;
    private final ApplicationEventPublisher eventPublisher;

    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    @Async
    public void onLiveStreamingStarted(final LiveStreamingStartedEvent event) {
        // 1. 구독자 조회
        final List<User> subscribers = subscriptionReader
                .readSubscribersByChannelId(event.channelId());

        // 2. 알림 생성 (핵심 로직)
        final List<Notification> notifications = notificationWriter
                .writeForLiveStreamingStart(subscribers, channel, liveStreaming);

        // 3. 알림 생성 이벤트 발행 (전송 트리거)
        notifications.forEach(notification -> {
            eventPublisher.publishEvent(NotificationCreatedEvent.from(notification));
        });
    }
}
```

#### NotificationPushEventListener (api 모듈)
```java
@Component
@RequiredArgsConstructor
public class NotificationPushEventListener {
    private final SseEmitterManager sseEmitterManager;

    @Async
    @EventListener
    public void onNotificationCreated(final NotificationCreatedEvent event) {
        try {
            if (sseEmitterManager.hasConnection(event.receiverId())) {
                sseEmitterManager.sendNotification(event.receiverId(), event);
            } else {
                // TODO: WebPush 전송
            }
        } catch (Exception e) {
            // 푸시 실패가 알림 생성에 영향을 주지 않음
            log.warn("알림 푸시 전송 실패 - notificationId: {}, receiverId: {}",
                    event.notificationId(), event.receiverId(), e);
        }
    }
}
```

#### SseEmitterManager (api 모듈)
```java
@Component
public class SseEmitterManager {
    private static final Long SSE_TIMEOUT = 30 * 60 * 1000L; // 30분

    private final ConcurrentHashMap<Long, Set<SseEmitter>> emittersByUserId
        = new ConcurrentHashMap<>();

    public SseEmitter createConnection(final Long userId) {
        final SseEmitter emitter = new SseEmitter(SSE_TIMEOUT);

        // 연결 해제 핸들러 등록
        emitter.onCompletion(() -> removeEmitter(userId, emitter));
        emitter.onTimeout(() -> removeEmitter(userId, emitter));
        emitter.onError(throwable -> removeEmitter(userId, emitter));

        // 사용자별 연결 저장 (멀티 탭 지원)
        emittersByUserId.compute(userId, (key, emitters) -> {
            if (emitters == null) {
                emitters = ConcurrentHashMap.newKeySet();
            }
            emitters.add(emitter);
            return emitters;
        });

        sendInitialEvent(userId, emitter);
        return emitter;
    }

    public void sendNotification(final Long userId, final NotificationCreatedEvent event) {
        final Set<SseEmitter> emitters = emittersByUserId.get(userId);
        if (emitters == null || emitters.isEmpty()) {
            return;
        }

        emitters.forEach(emitter -> send(emitter, userId, event));
    }

    private void send(final SseEmitter emitter, final Long userId,
                     final NotificationCreatedEvent event) {
        try {
            emitter.send(SseEmitter.event()
                    .name("notification")
                    .data(event));
        } catch (IOException e) {
            removeEmitter(userId, emitter);
        }
    }
}
```

## 결론

이벤트 기반 분리 방식을 선택함으로써:
- 알림 생성(핵심 로직)과 푸시 전송(부가 기능)의 명확한 분리를 달성했습니다
- 현재 아키텍처와의 일관성을 유지했습니다
