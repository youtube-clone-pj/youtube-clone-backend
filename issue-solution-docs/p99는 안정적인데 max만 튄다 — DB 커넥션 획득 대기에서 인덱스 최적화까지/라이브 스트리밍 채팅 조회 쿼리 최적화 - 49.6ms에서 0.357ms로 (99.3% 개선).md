# 라이브 스트리밍 채팅 조회 쿼리 최적화 - 49.6ms에서 0.357ms로 (99.3% 개선)

## 목차
1. [테스트 환경](#테스트-환경)
2. [성능 개선 결과 요약](#성능-개선-결과-요약)
3. [인덱스 적용 전 (fk_chat_live_streaming 사용)](#1-인덱스-적용-전-fk_chat_live_streaming-사용)
4. [복합 인덱스 1차 시도 (live_streaming_id, id)](#2-복합-인덱스-1차-시도-live_streaming_id-id)
5. [복합 인덱스 최종 (live_streaming_id, deleted_date, id)](#3-복합-인덱스-최종-live_streaming_id-deleted_date-id)
6. [결론 및 권장사항](#결론-및-권장사항)
7. [LiveStreamingChat 테이블 역정규화 및 LIMIT 최적화](#4-livestreamingchat-테이블-역정규화-및-limit-최적화)

---

## 테스트 환경

### 테스트 데이터
- User: 100,000명
- Channel: 100,000개
- Subscription: 2,000,000+ 건
- Push Subscription: 50,000건
- Live Streaming: 1,111개 (LIVE 1개 + ENDED 1,110개)
- Live Streaming Chat: 300,000건

### 대상 쿼리

**LiveStreamingChatRepository.findNewChatsAfter**

```java
@Query("SELECT new com.youtube.live.interaction.livestreaming.repository.dto.ChatMessageResponse(" +
        "c.id, u.username, c.message, c.messageType, u.profileImageUrl, c.createdDate) " +
        "FROM LiveStreamingChat c " +
        "JOIN c.user u " +
        "WHERE c.liveStreaming.id = :livestreamId AND c.id > :lastChatId " +
        "ORDER BY c.id ASC")
List<ChatMessageResponse> findNewChatsAfter(
        @Param("livestreamId") final Long livestreamId,
        @Param("lastChatId") final Long lastChatId
);
```

**실행되는 SQL**
```sql
EXPLAIN ANALYZE
SELECT chat.id,
       user.username,
       chat.message,
       chat.message_type,
       user.profile_image_url,
       chat.created_date
FROM live_streaming_chat chat
JOIN users user ON user.id = chat.user_id AND (user.deleted_date IS NULL)
WHERE (chat.deleted_date IS NULL)
  AND chat.live_streaming_id = ?
  AND chat.id > ?
ORDER BY chat.id;
```

---

## 성능 개선 결과 요약

| 테스트 케이스 | 인덱스 없음 | idx(live_streaming_id, id) | idx(live_streaming_id, deleted_date, id) |
|------------|-----------|---------------------------|----------------------------------------|
| **초기 데이터 (id > 0)** | 51.8ms | 63.5ms | **49.6ms** ✓ |
| **중간 데이터 (id > 50000)** | 57.1ms | 33.9ms | **24.3ms** ✓ |
| **마지막 데이터 (id > 99999)** | 0.62ms | 0.969ms | **0.037ms** ✓ |

**최종 권장 인덱스**: `(live_streaming_id, deleted_date, id)`

---

## 1. 인덱스 적용 전 (fk_chat_live_streaming 사용)

> `fk_chat_live_streaming`은 `live_streaming_id`만 명시적으로 인덱싱하지만, InnoDB의 모든 세컨더리 인덱스는 PK를 암시적으로 포함하므로 실제로는 `(live_streaming_id, id)` 복합 인덱스처럼 동작합니다. 이로 인해 `WHERE live_streaming_id = 2 AND id > 0 ORDER BY id` 쿼리에서 별도의 정렬 작업 없이 인덱스 순서대로 데이터를 읽을 수 있습니다.

### 1.1 초기 데이터 조회 (id > 0, 10,000건 조회)

**실행 계획**
```sql
-> Nested loop inner join  (cost=9006 rows=186) (actual time=0.043..51.8 rows=10000 loops=1)
    -> Filter: (chat.deleted_date is null)  (cost=8356 rows=1857) (actual time=0.0297..19.3 rows=10000 loops=1)
        -> Index range scan on chat using fk_chat_live_streaming over (live_streaming_id = 2 AND 0 < id),
           with index condition: ((chat.live_streaming_id = 2) and (chat.id > 0))
           (cost=8356 rows=18568) (actual time=0.0289..18.5 rows=10000 loops=1)
    -> Filter: (user.deleted_date is null)  (cost=0.25 rows=0.1) (actual time=0.00303..0.0031 rows=1 loops=10000)
        -> Single-row index lookup on user using PRIMARY (id=chat.user_id)
           (cost=0.25 rows=1) (actual time=0.00292..0.00295 rows=1 loops=10000)
```

**시간 분석**
1. **Index range scan**: 18.5ms에 10,000건 완료
2. **Filter (deleted_date)**: 19.3ms에 10,000건 완료 (추가 0.8ms)
3. **User 조인**: 51.8 - 19.3 = **32.5ms** (10,000 loops, 루프당 0.00325ms)

**총 실행 시간**: **51.8ms**
- 채팅 데이터 스캔: 19.3ms (37%)
- User 조인: 32.5ms (63%)

### 1.2 중간 데이터 조회 (id > 50000, 5,000건 조회)

**실행 계획**
```sql
-> Nested loop inner join  (cost=1352 rows=250) (actual time=22.8..57.1 rows=5000 loops=1)
    -> Sort: chat.id  (cost=1040 rows=2500) (actual time=22.7..24.8 rows=5000 loops=1)
        -> Filter: ((chat.live_streaming_id = 2) and (chat.deleted_date is null) and (chat.id > 50000))
           (cost=1040 rows=2500) (actual time=0.335..13.8 rows=5000 loops=1)
            -> Intersect rows sorted by row ID  (cost=1040 rows=2500) (actual time=0.322..13.2 rows=5000 loops=1)
                -> Index range scan on chat using fk_chat_live_streaming over (live_streaming_id = 2 AND 50000 < id)
                   (cost=537e-6..2.69 rows=5000) (actual time=0.294..1.96 rows=5000 loops=1)
    -> Filter: (user.deleted_date is null)  (cost=0.25 rows=0.1) (actual time=0.00622..0.00629 rows=1 loops=5000)
        -> Single-row index lookup on user using PRIMARY (id=chat.user_id)
           (cost=0.25 rows=1) (actual time=0.0061..0.00612 rows=1 loops=5000)
```

**시간 분석**
1. **Index range scan**: 1.96ms에 5,000건 완료
2. **Intersect rows**: 13.2ms에 5,000건 완료 (추가 11.24ms)
3. **Filter**: 13.8ms에 5,000건 완료 (추가 0.6ms)
4. **Sort**:
   - 정렬 작업: 22.7 - 13.8 = **8.9ms**
   - 정렬된 데이터 읽기: 24.8 - 22.7 = 2.1ms
   - Sort 완료: 24.8ms
5. **User 조인**: 57.1 - 24.8 = **32.3ms** (5,000 loops, 루프당 0.00646ms)

**총 실행 시간**: **57.1ms**
- Index + Intersect + Filter: 13.8ms (24%)
- **Sort 작업: 11.0ms (19%)**
- User 조인: 32.3ms (57%)

### 1.3 마지막 데이터 조회 (id > 99999, 1건 조회)

**실행 계획**
```sql
-> Nested loop inner join  (cost=0.525 rows=0.1) (actual time=0.62..0.62 rows=1 loops=1)
    -> Sort: chat.id  (cost=0.4 rows=1) (actual time=0.523..0.523 rows=1 loops=1)
        -> Filter: ((chat.live_streaming_id = 2) and (chat.deleted_date is null) and (chat.id > 99999))
           (cost=0.4 rows=1) (actual time=0.416..0.453 rows=1 loops=1)
            -> Intersect rows sorted by row ID  (cost=0.4 rows=1) (actual time=0.398..0.435 rows=1 loops=1)
                -> Index range scan on chat using fk_chat_live_streaming over (live_streaming_id = 2 AND 99999 < id)
                   (cost=0.25..0.25 rows=1) (actual time=0.338..0.374 rows=1 loops=1)
    -> Filter: (user.deleted_date is null)  (cost=0.35 rows=0.1) (actual time=0.0905..0.0907 rows=1 loops=1)
        -> Single-row index lookup on user using PRIMARY (id=chat.user_id)
           (cost=0.35 rows=1) (actual time=0.0892..0.0893 rows=1 loops=1)
```

**시간 분석**
1. **Index + Intersect + Filter**: 0.453ms
2. **Sort**: 0.523 - 0.453 = 0.07ms
3. **User 조인**: 0.62 - 0.523 = 0.097ms

**총 실행 시간**: **0.62ms**

---

## 2. 복합 인덱스 1차 시도 (live_streaming_id, id)

```sql
CREATE INDEX idx_livestreaming_id_id ON live_streaming_chat (live_streaming_id, id);
```

### 2.1 초기 데이터 조회 (id > 0, 10,000건 조회)

**실행 계획**
```sql
-> Nested loop inner join  (cost=9006 rows=186) (actual time=0.324..63.5 rows=10000 loops=1)
    -> Filter: (chat.deleted_date is null)  (cost=8356 rows=1857) (actual time=0.177..21.1 rows=10000 loops=1)
        -> Index range scan on chat using idx_livestreaming_id_id over (live_streaming_id = 2 AND 0 < id),
           with index condition: ((chat.live_streaming_id = 2) and (chat.id > 0))
           (cost=8356 rows=18568) (actual time=0.176..20.4 rows=10000 loops=1)
    -> Filter: (user.deleted_date is null)  (cost=0.25 rows=0.1) (actual time=0.00403..0.00411 rows=1 loops=10000)
        -> Single-row index lookup on user using PRIMARY (id=chat.user_id)
           (cost=0.25 rows=1) (actual time=0.00393..0.00395 rows=1 loops=10000)
```

**시간 분석**
1. **Index range scan**: 20.4ms에 10,000건 완료
2. **Filter (deleted_date)**: 21.1ms에 10,000건 완료 (추가 0.7ms)
3. **User 조인**: 63.5 - 21.1 = **42.4ms** (10,000 loops, 루프당 0.00424ms)

**총 실행 시간**: **63.5ms** (인덱스 없음 대비 +11.7ms)
- 채팅 데이터 스캔: 21.1ms (33%)
- User 조인: 42.4ms (67%)

### 2.2 중간 데이터 조회 (id > 50000, 5,000건 조회)

**실행 계획**
```sql
-> Nested loop inner join  (cost=2425 rows=50) (actual time=0.316..33.9 rows=5000 loops=1)
    -> Filter: (chat.deleted_date is null)  (cost=2250 rows=500) (actual time=0.197..10.3 rows=5000 loops=1)
        -> Index range scan on chat using idx_livestreaming_id_id over (live_streaming_id = 2 AND 50000 < id),
           with index condition: ((chat.live_streaming_id = 2) and (chat.id > 50000))
           (cost=2250 rows=5000) (actual time=0.196..9.98 rows=5000 loops=1)
    -> Filter: (user.deleted_date is null)  (cost=0.25 rows=0.1) (actual time=0.00452..0.00459 rows=1 loops=5000)
        -> Single-row index lookup on user using PRIMARY (id=chat.user_id)
           (cost=0.25 rows=1) (actual time=0.00442..0.00444 rows=1 loops=5000)
```

**시간 분석**
1. **Index range scan**: 9.98ms에 5,000건 완료
2. **Filter (deleted_date)**: 10.3ms에 5,000건 완료 (추가 0.32ms)
3. **User 조인**: 33.9 - 10.3 = **23.6ms** (5,000 loops, 루프당 0.00472ms)

**총 실행 시간**: **33.9ms** (인덱스 없음 대비 -23.2ms, **40.6% 개선**)
- 채팅 데이터 스캔: 10.3ms (30%)
- User 조인: 23.6ms (70%)

### 2.3 마지막 데이터 조회 (id > 99999, 1건 조회)

**실행 계획**
```sql
-> Nested loop inner join  (cost=0.745 rows=0.01) (actual time=0.866..0.969 rows=1 loops=1)
    -> Filter: (chat.deleted_date is null)  (cost=0.71 rows=0.1) (actual time=0.586..0.688 rows=1 loops=1)
        -> Index range scan on chat using idx_livestreaming_id_id over (live_streaming_id = 2 AND 99999 < id),
           with index condition: ((chat.live_streaming_id = 2) and (chat.id > 99999))
           (cost=0.71 rows=1) (actual time=0.583..0.685 rows=1 loops=1)
    -> Filter: (user.deleted_date is null)  (cost=0.35 rows=0.1) (actual time=0.241..0.242 rows=1 loops=1)
        -> Single-row index lookup on user using PRIMARY (id=chat.user_id)
           (cost=0.35 rows=1) (actual time=0.232..0.232 rows=1 loops=1)
```

**시간 분석**
1. **Index range scan**: 0.685ms
2. **Filter**: 0.688ms (추가 0.003ms)
3. **User 조인**: 0.969 - 0.688 = 0.281ms

**총 실행 시간**: **0.969ms** (인덱스 없음 대비 +0.349ms)

---

## 3. 복합 인덱스 최종 (live_streaming_id, deleted_date, id)

```sql
CREATE INDEX idx_livestreaming_id_deleted_date_id
ON live_streaming_chat (live_streaming_id, deleted_date, id);
```

### 3.1 초기 데이터 조회 (id > 0, 10,000건 조회)

**실행 계획**
```sql
-> Nested loop inner join  (cost=15045 rows=1881) (actual time=0.224..49.6 rows=10000 loops=1)
    -> Index range scan on chat using idx_livestreaming_id_deleted_date_id
       over (live_streaming_id = 2 AND deleted_date = NULL AND 0 < id),
       with index condition: ((chat.live_streaming_id = 2) and (chat.deleted_date is null) and (chat.id > 0))
       (cost=8463 rows=18806) (actual time=0.142..16.2 rows=10000 loops=1)
    -> Filter: (user.deleted_date is null)  (cost=0.25 rows=0.1) (actual time=0.00314..0.00321 rows=1 loops=10000)
        -> Single-row index lookup on user using PRIMARY (id=chat.user_id)
           (cost=0.25 rows=1) (actual time=0.00305..0.00307 rows=1 loops=10000)
```

**시간 분석**
1. **Index range scan**: 16.2ms에 10,000건 완료 (**Filter 단계 없음!**)
2. **User 조인**: 49.6 - 16.2 = **33.4ms** (10,000 loops, 루프당 0.00334ms)

**총 실행 시간**: **49.6ms** (인덱스 없음 대비 -2.2ms, **4.2% 개선**)
- 채팅 데이터 스캔: 16.2ms (33%)
- User 조인: 33.4ms (67%)

### 3.2 중간 데이터 조회 (id > 50000, 5,000건 조회)

**실행 계획**
```sql
-> Nested loop inner join  (cost=4000 rows=500) (actual time=0.043..24.3 rows=5000 loops=1)
    -> Index range scan on chat using idx_livestreaming_id_deleted_date_id
       over (live_streaming_id = 2 AND deleted_date = NULL AND 50000 < id),
       with index condition: ((chat.live_streaming_id = 2) and (chat.deleted_date is null) and (chat.id > 50000))
       (cost=2250 rows=5000) (actual time=0.0243..9.06 rows=5000 loops=1)
    -> Filter: (user.deleted_date is null)  (cost=0.25 rows=0.1) (actual time=0.00283..0.00291 rows=1 loops=5000)
        -> Single-row index lookup on user using PRIMARY (id=chat.user_id)
           (cost=0.25 rows=1) (actual time=0.00273..0.00276 rows=1 loops=5000)
```

**시간 분석**
1. **Index range scan**: 9.06ms에 5,000건 완료 (**Filter 단계 없음!**)
2. **User 조인**: 24.3 - 9.06 = **15.24ms** (5,000 loops, 루프당 0.00305ms)

**총 실행 시간**: **24.3ms** (인덱스 없음 대비 -32.8ms, **57.4% 개선**)
- 채팅 데이터 스캔: 9.06ms (37%)
- User 조인: 15.24ms (63%)

### 3.3 마지막 데이터 조회 (id > 99999, 1건 조회)

**실행 계획**
```sql
-> Nested loop inner join  (cost=1.06 rows=0.1) (actual time=0.0334..0.0368 rows=1 loops=1)
    -> Index range scan on chat using idx_livestreaming_id_deleted_date_id
       over (live_streaming_id = 2 AND deleted_date = NULL AND 99999 < id),
       with index condition: ((chat.live_streaming_id = 2) and (chat.deleted_date is null) and (chat.id > 99999))
       (cost=0.71 rows=1) (actual time=0.0214..0.0246 rows=1 loops=1)
    -> Filter: (user.deleted_date is null)  (cost=0.26 rows=0.1) (actual time=0.0103..0.0104 rows=1 loops=1)
        -> Single-row index lookup on user using PRIMARY (id=chat.user_id)
           (cost=0.26 rows=1) (actual time=0.00983..0.00988 rows=1 loops=1)
```

**시간 분석**
1. **Index range scan**: 0.0246ms
2. **User 조인**: 0.0368 - 0.0246 = 0.0122ms

**총 실행 시간**: **0.037ms** (인덱스 없음 대비 -0.583ms, **94% 개선**)

---

## 결론 및 권장사항

### 성능 개선 상세 비교

| 케이스 | 인덱스 없음 | idx(live_streaming_id, id) | idx(live_streaming_id, deleted_date, id) | 최종 개선율 |
|--------|-----------|---------------------------|----------------------------------------|-----------|
| **초기 (10,000건)** | 51.8ms | 63.5ms (↓ 악화) | **49.6ms** | **4.2% ↓** |
| - 채팅 스캔 | 19.3ms | 21.1ms | **16.2ms** | 16.1% ↓ |
| - User 조인 | 32.5ms | 42.4ms | 33.4ms | - |
| **중간 (5,000건)** | 57.1ms | 33.9ms (↓ 40.6%) | **24.3ms** | **57.4% ↓** |
| - 채팅 스캔 | 13.8ms | 10.3ms | **9.06ms** | 34.3% ↓ |
| - Sort | **8.9ms** | **제거** | **제거** | 100% ↓ |
| - User 조인 | 32.3ms | 23.6ms | **15.24ms** | 52.8% ↓ |
| **마지막 (1건)** | 0.62ms | 0.969ms (↑ 악화) | **0.037ms** | **94% ↓** |

### 최종 권장 인덱스

```sql
CREATE INDEX idx_livestreaming_id_deleted_date_id
ON live_streaming_chat (live_streaming_id, deleted_date, id);
```

---

## 4. LiveStreamingChat 테이블 역정규화 및 LIMIT 최적화

### 4.1 왜 역정규화인가?

#### User 조인의 성능 병목

섹션 3의 성능 분석 결과, User 조인이 전체 실행 시간의 **60% 이상**을 차지한다는 것을 확인했다.

- 초기 데이터 (10,000건): User 조인 33.4ms / 전체 49.6ms = **67%**
- 중간 데이터 (5,000건): User 조인 15.24ms / 전체 24.3ms = **63%**

인덱스 최적화만으로는 조인 비용을 근본적으로 제거할 수 없다.

#### 라이브 스트리밍 채팅의 도메인 특성

라이브 스트리밍 채팅은 역정규화에 적합한 도메인 특성을 가지고 있다.

**1. 읽기 집약적 (Read-Heavy) 워크로드**

- **읽기:쓰기 비율**: 대부분의 시청자는 채팅을 읽기만 하고 작성하지 않는다. 쓰기보다 읽기가 압도적으로 많다.
- **4초 폴링**: 모든 시청자가 4초마다 새로운 채팅을 조회한다. 시청자 1,000명이라면 초당 **250개의 SELECT 쿼리**가 발생한다.
- **성능 우선순위**: 이러한 환경에서는 쓰기 성능보다 읽기 성능이 압도적으로 중요하다.

**2. 사용자 정보의 불변성**

- **변경 빈도**: `username`과 `profileImageUrl`은 자주 변경되지 않는다. 대부분의 사용자는 이 정보를 한 번 설정하고 거의 변경하지 않는다.
- **스냅샷 개념**: 과거 채팅에 표시되는 사용자 정보는 "그 시점의 스냅샷"으로 보존하는 것이 오히려 자연스럽다. 사용자가 닉네임을 변경했다고 해서 과거 채팅의 닉네임까지 변경할 필요는 없다.

**3. 실시간성 요구사항**

- **빠른 응답 필수**: 라이브 채팅은 실시간 소통이 핵심이다. 100ms 이상의 지연은 사용자 경험을 크게 해친다.
- **예측 가능한 성능**: 시청자가 갑자기 증가하거나 채팅이 폭발적으로 늘어날 때도 일정한 응답 속도를 보장해야 한다.

#### 역정규화의 트레이드오프

| 항목 | 정규화 (조인) | 역정규화 |
|------|------------|---------|
| **읽기 성능** | User 조인 필요 (60%+ 오버헤드) | 조인 불필요 (단일 테이블 스캔) |
| **쓰기 성능** | User 테이블만 INSERT | Chat 테이블에 중복 데이터 INSERT |
| **데이터 일관성** | 항상 최신 사용자 정보 | 사용자 정보 변경 시 과거 채팅은 불변 |
| **스토리지** | 최소 | 증가 (username, profileImageUrl 중복) |

라이브 스트리밍 채팅 도메인에서는:
- 쓰기보다 읽기 비율이 매우 높으므로 읽기 성능 개선이 훨씬 중요하다.
- 사용자 정보 변경이 드물고, 과거 채팅은 스냅샷으로 보존하는 것이 자연스럽다.
- 스토리지 증가보다 조인 제거로 인한 성능 향상이 더 큰 가치를 제공한다.

### 4.2 왜 LIMIT 50인가?

라이브 스트리밍 채팅의 핵심은 **"현재의 현장감을 느끼는 것"**이다. 이러한 특성을 고려하여 LIMIT 50을 적용했다.

#### 1. 사용자 경험 (UX): "어차피 못 읽는다"

- **인간의 한계**: 4초 동안 채팅이 50개가 올라온다면, 1초에 12.5개다. 사람은 이를 읽기 어려우며, 단지 "텍스트가 흐르는구나" 정도만 인지한다.
- **LIMIT 50의 의미**: 4초에 50개면 충분히 "채팅창이 폭발하고 있다(Hype)"는 느낌을 줄 수 있다. 굳이 1,000개를 다 가져와서 보여줄 필요가 없다.

#### 2. 프론트엔드 성능: "렌더링이 버벅거린다"

- **화면 렌더링 부하**: 4초마다 1,000개의 채팅을 화면에 그리면 브라우저가 버벅거리고 스크롤이 끊긴다. 50개 정도면 충분히 부드러운 사용자 경험을 제공할 수 있다.

#### 3. 백엔드(DB) 성능: "안정성이 최우선이다"

- **예측 가능한 부하**: LIMIT 50을 걸면 채팅이 100만 개가 쌓여 있어도 DB는 딱 50개만 읽고 멈춘다. 응답 속도가 데이터 양에 상관없이 **항상 일정(Constant Time)**하게 유지된다. 이것이 시스템 안정성의 핵심이다.

### 4.2 역정규화 후 LIMIT 50 적용 결과

User 테이블 조인을 제거한 역정규화된 테이블에 `idx_livestreaming_id_deleted_date_id` 인덱스와 LIMIT 50을 적용한 결과다.

#### 초기 데이터 조회 (id > 0, LIMIT 50)

```sql
-> Limit: 50 row(s)  (cost=8463 rows=50) (actual time=0.163..0.357 rows=50 loops=1)
    -> Index range scan on lsc1_0 using idx_livestreaming_id_deleted_date_id
       over (live_streaming_id = 2 AND deleted_date = NULL AND 0 < id),
       with index condition: ((lsc1_0.live_streaming_id = 2) and (lsc1_0.deleted_date is null) and (lsc1_0.id > 0))
       (cost=8463 rows=18806) (actual time=0.154..0.343 rows=50 loops=1)
```

**실행 시간**: **0.357ms** (섹션 3.1의 10,000건 조회 49.6ms 대비 **99.3% 개선**)

#### 중간 데이터 조회 (id > 50000, LIMIT 50)

```sql
-> Limit: 50 row(s)  (cost=2250 rows=50) (actual time=0.234..0.433 rows=50 loops=1)
    -> Index range scan on lsc1_0 using idx_livestreaming_id_deleted_date_id
       over (live_streaming_id = 2 AND deleted_date = NULL AND 50000 < id),
       with index condition: ((lsc1_0.live_streaming_id = 2) and (lsc1_0.deleted_date is null) and (lsc1_0.id > 50000))
       (cost=2250 rows=5000) (actual time=0.22..0.415 rows=50 loops=1)
```

**실행 시간**: **0.433ms** (섹션 3.2의 5,000건 조회 24.3ms 대비 **98.2% 개선**)

#### 마지막 데이터 조회 (id > 99999, LIMIT 50)

```sql
-> Limit: 50 row(s)  (cost=0.71 rows=1) (actual time=0.0332..0.0379 rows=1 loops=1)
    -> Index range scan on lsc1_0 using idx_livestreaming_id_deleted_date_id
       over (live_streaming_id = 2 AND deleted_date = NULL AND 99999 < id),
       with index condition: ((lsc1_0.live_streaming_id = 2) and (lsc1_0.deleted_date is null) and (lsc1_0.id > 99999))
       (cost=0.71 rows=1) (actual time=0.0322..0.0368 rows=1 loops=1)
```

**실행 시간**: **0.0379ms** (섹션 3.3의 1건 조회 0.037ms와 유사)

### 4.3 최종 성능 개선 요약

| 측정 항목 | 조인 포함 (섹션 3) | 역정규화 + LIMIT 50 | 개선율 |
|---------|------------------|-------------------|--------|
| **초기 데이터** | 49.6ms (10,000건) | **0.357ms** (50건) | **99.3% ↓** |
| **중간 데이터** | 24.3ms (5,000건) | **0.433ms** (50건) | **98.2% ↓** |
| **마지막 데이터** | 0.037ms (1건) | **0.0379ms** (1건) | 유사 |

**핵심 개선 포인트**:
1. **User 조인 제거**: 역정규화로 조인 비용 완전 제거 (전체 실행 시간의 60% 이상을 차지하던 부분)
2. **LIMIT 50**: 실제 필요한 데이터만 조회하여 Index Scan 비용 최소화
3. **예측 가능한 성능**: 데이터 양에 관계없이 항상 1ms 이내의 응답 시간 보장
