# 라이브 스트리밍 실시간 시청자 수 카운팅 개선

## 배경

유튜브 클론 프로젝트에서 라이브 스트리밍 기능을 구현하면서, 실시간으로 시청자 수를 집계하고 표시하는 기능이 필요했습니다.

실시간 시청자 수는 클라이언트가 20초마다 서버에 "살아있음"을 알리는 **Heartbeat 요청**을 보내고, 서버가 30초 동안 Heartbeat가 없는 시청자를 자동으로 제외하는 **TTL(Time To Live)** 방식으로 동작합니다.

초기에는 HTTP Session ID를 시청자 식별자로 사용했으나, 동일한 사용자가 여러 명으로 중복 카운팅되는 문제가 발생했습니다. 이 문서는 해당 문제를 어떻게 해결했는지 기록합니다.

---

## 문제 정의

### 중복 카운팅 문제

HTTP Session ID를 시청자 식별자로 사용할 경우, 다음과 같은 시나리오에서 동일한 사용자가 여러 명으로 중복 카운팅됩니다.

**시나리오 1: 로그인 전후**
```
1. 비로그인 상태로 접속 → Session ID: "ABC123" → 시청자 수 +1
2. 로그인 수행 → Session ID: "DEF456" (새 세션으로 변경) → 시청자 수 +1
결과: 실제 1명이지만 2명으로 카운팅됨
```

**시나리오 2: 여러 탭 사용**
```
1. 탭1에서 접속 → Session ID: "ABC123" → 시청자 수 +1
2. 탭2에서 접속 → Session ID: "DEF456" → 시청자 수 +1
3. 탭3에서 접속 → Session ID: "GHI789" → 시청자 수 +1
결과: 실제 1명이지만 3명으로 카운팅됨
```

### 근본 원인

- **브라우저 탭마다 Session ID가 달라질 수 있습니다**
  - 브라우저 구현에 따라 탭마다 독립적인 세션이 생성될 수 있습니다
- **Session ID는 사용자의 고유 식별자가 아닙니다**
  - Session ID는 서버-클라이언트 간 통신을 위한 임시 값입니다

---

## 해결 방안

### 하이브리드 식별 방식

사용자의 로그인 상태에 따라 다른 식별자를 사용하도록 설계했습니다.

| 사용자 유형 | 식별자 | 형식 | 설명 |
|-----------|-------|------|------|
| 로그인 사용자 | `userId` | `user:{userId}` | DB의 사용자 고유 ID 사용 |
| 비로그인 사용자 | `clientId` | `client:{clientId}` | 서버가 생성한 UUID 사용 |

**동작 원리**
- 로그인한 사용자는 여러 탭에서 접속해도 동일한 `userId`를 가지므로 1명으로 카운팅됩니다
- 비로그인 사용자는 서버가 생성한 `clientId`를 세션에 저장하여 재사용하므로 1명으로 카운팅됩니다

### clientId 생성 및 관리

비로그인 사용자를 식별하기 위한 `clientId`는 다음과 같이 관리합니다:

```java
private String getOrCreateClientId(final HttpSession session) {
    String clientId = (String) session.getAttribute(SESSION_CLIENT_ID);
    if (clientId == null) {
        clientId = UUID.randomUUID().toString();
        session.setAttribute(SESSION_CLIENT_ID, clientId);
    }
    return clientId;
}
```

**핵심 포인트**
- `clientId`를 **Session Attribute**로 저장합니다
- Session ID 자체를 사용하지 않고, 세션에 저장된 속성 값을 사용합니다

**Session ID vs Session Attribute 비교**

| 구분 | Session ID 직접 사용 | Session Attribute 사용 |
|-----|-------------------|---------------------|
| 로그인 전 | `sessionId: "ABC123"` | `clientId: "uuid-1"` (세션에 저장) |
| 로그인 후 | `sessionId: "DEF456"` (변경됨) | `clientId: "uuid-1"` (유지됨) |
| 중복 카운팅 | ❌ 발생 | ✅ 방지 |

---

## 아키텍처 설계

### Heartbeat 기반 TTL 시스템

실시간 시청자 수는 클라이언트의 주기적인 Heartbeat와 서버의 TTL 관리로 동작합니다.

**Heartbeat (클라이언트)**
- 클라이언트가 20초마다 `GET /api/v2/livestreams/{id}/live-stats` 요청을 보냅니다
- 이 요청은 실시간 통계(시청자 수, 좋아요 수)를 조회하면서 동시에 "나는 아직 시청 중"이라는 신호를 보냅니다

**TTL (서버)**
- 서버는 각 시청자의 마지막 Heartbeat 시간을 기록합니다
- 마지막 Heartbeat 이후 30초가 지나면 해당 시청자를 자동으로 제외합니다

**폴링 주기와 TTL 설정**
- 폴링 주기: 20초
- TTL: 30초 (폴링 주기 × 1.5)

TTL을 폴링 주기보다 길게 설정하는 이유:
1. **네트워크 지연 허용**: 20초 폴링이 실제로는 22~23초에 도착할 수 있습니다
2. **일시적 연결 끊김 대응**: 1회 폴링 실패 시에도 안정적으로 카운팅을 유지합니다

**동작 예시**
```
정상 시청:
00:00 폴링 → 00:20 폴링 → 00:40 폴링 → 계속 시청자로 유지

탭 닫음:
00:00 폴링 → 00:20 탭 닫음 (마지막 폴링) → 00:50 TTL 경과 → 시청자에서 제외

네트워크 불안정:
00:00 폴링 → 00:22 폴링(2초 지연) → 00:45 폴링(3초 지연) → 안정적으로 유지
```

### 데이터 구조

서버는 라이브 스트리밍별로 시청자 정보를 메모리에 저장합니다.

```java
ConcurrentHashMap<Long, ConcurrentHashMap<String, Instant>> liveStreamViewers

// 예시:
livestreamId: 1L → {
    "user:100": Instant(2025-12-04 10:00:00),      // 로그인 사용자 (userId: 100)
    "user:101": Instant(2025-12-04 10:00:05),      // 로그인 사용자 (userId: 101)
    "client:abc-def": Instant(2025-12-04 10:00:10) // 비로그인 사용자
}
```

**시청자 수 계산**
- `viewerCount = Map.size()`
- 같은 `viewerId`로 여러 번 Heartbeat가 들어와도 Map의 크기는 증가하지 않습니다
- 마지막 접속 시간(`Instant`)만 업데이트됩니다

---

## 구현

### 1. LiveStreamingViewerManager

Heartbeat 기록 및 시청자 수 관리를 담당하는 컴포넌트입니다.

**Heartbeat 기록**

`LiveStreamingViewerManager.java:46-60`
```java
public void recordHeartbeat(final Long livestreamId, final String clientId, final Long userId) {
    // userId가 있으면 "user:{userId}", 없으면 "client:{clientId}" 형식으로 viewerId 생성
    final String viewerId = userId != null
            ? "user:" + userId
            : "client:" + clientId;

    liveStreamViewers.compute(livestreamId, (id, viewers) -> {
        if (viewers == null) {
            viewers = new ConcurrentHashMap<>();
        }
        viewers.put(viewerId, Instant.now());
        return viewers;
    });
}
```

**시청자 수 조회 및 만료된 시청자 정리**

`LiveStreamingViewerManager.java:62-74`
```java
public int getViewerCount(final Long livestreamId) {
    cleanupExpiredViewers(livestreamId);  // 먼저 만료된 시청자 제거
    return liveStreamViewers.getOrDefault(livestreamId, new ConcurrentHashMap<>()).size();
}

private void cleanupExpiredViewers(final Long livestreamId) {
    final Instant cutoffTime = Instant.now().minus(Duration.ofSeconds(VIEWER_TTL_SECONDS));

    liveStreamViewers.computeIfPresent(livestreamId, (id, viewers) -> {
        viewers.entrySet().removeIf(entry -> entry.getValue().isBefore(cutoffTime));
        return viewers.isEmpty() ? null : viewers;
    });
}
```

**스케줄러: 주기적인 메모리 정리**

`LiveStreamingViewerManager.java:80-83`
```java
@Scheduled(fixedRate = 1800000) // 30분마다 실행
public void cleanupAllExpiredViewers() {
    liveStreamViewers.keySet().forEach(this::cleanupExpiredViewers);
}
```

- 갑자기 종료된 라이브 스트리밍의 메모리 누수를 방지합니다

### 2. LiveStreamingQueryService

Heartbeat 기록과 실시간 통계 조회를 처리하는 서비스입니다.

`LiveStreamingQueryService.java:24-35`
```java
public LiveStatsResponse pollLiveStats(
        final Long liveStreamingId,
        final String clientId,
        final Long userId
) {
    // Heartbeat 기록
    liveStreamingViewerManager.recordHeartbeat(liveStreamingId, clientId, userId);

    // 실시간 통계 조회
    final int viewerCount = liveStreamingViewerManager.getViewerCount(liveStreamingId);
    final int likeCount = reactionReader.countBy(liveStreamingId, ReactionType.LIKE);
    return new LiveStatsResponse(viewerCount, likeCount);
}
```

### 3. LiveStreamingV2Controller

클라이언트의 폴링 요청을 처리하는 컨트롤러입니다.

`LiveStreamingV2Controller.java:51-72`
```java
@GetMapping("/{liveStreamingId}/live-stats")
public ResponseEntity<LiveStatsResponse> getLiveStats(
        @PathVariable final Long liveStreamingId,
        final HttpSession session
) {
    // 세션에서 clientId 가져오거나 새로 생성
    final String clientId = getOrCreateClientId(session);

    // 로그인한 경우에만 userId가 세션에 존재
    final Long userId = (Long) session.getAttribute(SESSION_USER_ID);

    // Heartbeat 기록 + 실시간 통계 조회
    final LiveStatsResponse response = liveStreamingQueryService.pollLiveStats(
            liveStreamingId,
            clientId,
            userId
    );

    return ResponseEntity.ok(response);
}
```

**참고: GET 요청의 Side Effect**

일반적으로 GET 요청은 조회만 해야 하지만, 이 엔드포인트는 시청자 Heartbeat를 기록하는 Side Effect가 있습니다. Polling 효율성을 위해 조회와 Heartbeat를 하나의 요청으로 결합했습니다.

---

## 제약사항 및 트레이드오프

### 1. 로그인 전후 일시적 중복 카운팅

**현상**

비로그인으로 시청 중인 사용자가 로그인하면 일시적으로 2명으로 카운팅됩니다.

```
로그인 전: client:abc-def로 카운팅 (+1명)
로그인 후: user:100으로 카운팅 (+1명)
→ 일시적으로 2명으로 카운팅됨
→ 30초(TTL) 후 client:abc-def가 자동 제거되어 1명으로 수렴
```

**트레이드오프**
- ✅ 간단한 구현
- ✅ 30초 후 자동으로 정확한 값으로 수렴
- ⚠️ 로그인 직후 최대 30초간 +1 오차 발생

**대안: 로그인 시 즉시 마이그레이션**

로그인 이벤트를 감지하여 비로그인 viewerId를 즉시 제거하는 방식도 가능합니다:

- ✅ 중복 카운팅 즉시 해결
- ❌ 구현 복잡도 증가 (로그인 이벤트 감지 로직 필요)

현재 구현은 간단한 TTL 방식을 선택했습니다. 30초는 실시간 집계에서 허용 가능한 오차 범위로 판단했습니다.

### 2. 메모리 기반 저장소

**현재 구현**

`ConcurrentHashMap`을 사용하여 메모리에 시청자 정보를 저장합니다.

**장점**
- 빠른 읽기/쓰기 성능
- 외부 저장소(Redis 등) 없이 동작

**제약사항**
- 서버 재시작 시 시청자 데이터 손실
- 다중 서버 환경에서 시청자 수가 분산됨
  - 예: 서버 A에 50명, 서버 B에 30명 접속 시 각 서버는 자신의 시청자 수만 알 수 있음

**확장 방안: Redis 도입**

다중 서버 환경을 지원하려면 Redis와 같은 중앙 저장소를 사용할 수 있습니다:

---

## 정리

### 핵심 구현 사항

1. **하이브리드 식별 방식**
   - 로그인 사용자: `userId` 기반 (`user:{userId}`)
   - 비로그인 사용자: `clientId` 기반 (`client:{clientId}`)

2. **clientId 관리**
   - 서버에서 UUID로 생성하여 HttpSession Attribute로 저장

3. **Heartbeat 기반 TTL 시스템**
   - 클라이언트 폴링 주기: 20초
   - ViewerManager TTL: 30초 (1.5배)
   - 네트워크 지연 및 일시적 연결 끊김 허용

4. **동시성 보장**
   - `ConcurrentHashMap` 사용
   - `compute`, `computeIfPresent` 메서드로 원자적 연산 보장

### 달성한 목표

- ✅ 로그인/비로그인 사용자 모두 여러 탭 사용 시 1명으로 카운팅
- ✅ 서버 기반 clientId 관리로 클라이언트 조작 방지
- ✅ 네트워크 지연 및 일시적 연결 끊김 허용
- ✅ 동시성 환경에서 안전한 시청자 수 관리

### 알려진 제약사항

- ⚠️ 로그인 전후 최대 30초간 일시적 중복 카운팅 (자동 수렴)
- ⚠️ 메모리 기반 저장소 (서버 재시작 시 손실, 다중 서버 환경 미지원)
  - Redis 도입으로 해결 가능