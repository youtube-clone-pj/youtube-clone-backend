# 알림 푸시 기능 구현 계획

## 1. 개요

### 1.1 목표
사용자에게 실시간으로 알림을 전달하는 푸시 기능을 구현한다. 브라우저 열림/닫힘 상태에 따라 적절한 방식으로 알림을 전달한다.

### 1.2 요구사항

#### 브라우저가 열려 있을 때
- 종 아이콘에 읽지 않은 알림 개수 표시
- 알림 센터 열 때: 모든 알림 목록 표시 (읽은 것 포함)
- 알림 센터 닫혀있을 때: 새 알림 발생 시 종 아이콘 숫자만 업데이트
- 알림 센터 열려있을 때: 새 알림 발생 시 숫자 업데이트 + 알림 내용 맨 위에 추가

#### 브라우저가 닫혀 있을 때
- WebPush를 통한 네이티브 브라우저 알림 전송

#### 읽음 처리
- 알림 센터를 열 때 표시된 모든 알림을 읽음 처리

#### 알림 개수
- 읽지 않은 알림만 카운트

---

## 2. 구현 현황 (2025-11-24 기준)

### 2.1 Phase 1: SSE 기반 실시간 알림 (진행 중)

#### 완료된 기능
- **SSE 연결 관리** (`SseEmitterManager`)
  - 사용자별 여러 연결 지원 (여러 탭/브라우저)
  - 타임아웃: 30분
  - 연결 생성/종료/에러 처리
  - 초기 연결 이벤트 전송

- **SSE 엔드포인트** (`NotificationController`)
  - `GET /api/v1/notifications/stream`: SSE 연결
  - 세션 기반 인증

- **알림 푸시 이벤트 시스템**
  - `NotificationCreatedEvent`: 알림 생성 시 발행되는 이벤트
  - `NotificationPushEventListener`: SSE로 알림 푸시 전송
  - `NotificationEventListener`: 라이브 스트리밍 시작 시 알림 생성 및 이벤트 발행

- **테스트**
  - `SseEmitterManagerTest`: 단위 테스트 (동시성 테스트 포함)

#### 구현된 플로우
```
[라이브 스트리밍 시작]
        ↓
[LiveStreamingStartedEvent 발행]
        ↓
[NotificationEventListener (비동기)]
  - 구독자 조회
  - Notification 엔티티 생성 및 저장
  - NotificationCreatedEvent 발행
        ↓
[NotificationPushEventListener (비동기)]
  - SSE 연결 확인
  - SSE 연결 있음 → SseEmitterManager로 전송
  - SSE 연결 없음 → (TODO) WebPush 전송
```

#### 미완료 기능
- Heartbeat 스케줄러 (연결 유지용)
- 연결 제한 로직 (사용자당 최대 N개)
- 읽음 처리 API
- 읽지 않은 알림 개수 조회 API
- SSE 통합 테스트

### 2.2 Phase 2: WebPush (미착수)

#### 미구현 기능
- PushSubscription 엔티티 및 Repository
- WebPush 구독/해지 API
- WebPushService 및 VAPID 설정
- WebPush 전송 로직 (`NotificationPushEventListener`에 TODO로 표시)
- 만료 구독 정리 스케줄러

### 2.3 의존성 추가 사항

**build.gradle.kts (api 모듈)**
```gradle
// SSE 테스트를 위한 WebFlux 의존성 추가
testImplementation("org.springframework:spring-webflux")
testImplementation("io.projectreactor:reactor-test")

testFixturesImplementation("org.springframework:spring-webflux")
testFixturesImplementation("io.projectreactor:reactor-test")
```

### 2.4 다음 단계

1. **SSE 기능 완성** (우선순위: 높음)
   - [ ] SSE 통합 테스트 작성
   - [ ] Heartbeat 스케줄러 구현
   - [ ] 연결 제한 로직 구현
   - [ ] 읽음 처리 API 구현
   - [ ] 읽지 않은 알림 개수 조회 API 구현

2. **WebPush 구현** (우선순위: 중간)
   - [ ] Database 스키마 생성 (`push_subscription`)
   - [ ] WebPush 구독/해지 API
   - [ ] WebPush 전송 로직
   - [ ] 만료 구독 정리

3. **테스트 완성** (우선순위: 높음)
   - [ ] E2E 시나리오 테스트
   - [ ] 부하 테스트 (선택)

---

## 3. 기술 스택 및 선택 이유

### 3.1 기술 조합: HTTP + SSE + WebPush

| 기술 | 역할 | 선택 이유 |
|------|------|-----------|
| **HTTP** | 알림 CRUD, 읽음 처리, WebPush 구독 관리 | RESTful API의 표준, 상태 변경 작업에 적합 |
| **SSE** | 브라우저 열려있을 때 실시간 알림 전송 | 단방향 통신으로 충분, WebSocket보다 간단하고 가벼움 |
| **WebPush** | 브라우저 닫혀있을 때 네이티브 알림 | 브라우저 닫혀있을 때 유일한 푸시 방법 |

### 3.2 SSE (Server-Sent Events) 선택 이유

#### 장점
- **단순성**: 알림은 서버 → 클라이언트 단방향 통신으로 충분
- **경량**: WebSocket보다 프로토콜 오버헤드가 작음
- **자동 재연결**: 브라우저가 네이티브로 재연결 지원
- **HTTP 호환**: 기존 HTTP 인프라 재사용 가능
- **독립성**: notification 모듈이 WebSocket 인프라에 의존하지 않음

#### 제약사항 및 해결방안
- **브라우저 연결 제한**: 도메인당 6개 연결 제한 (HTTP/1.1)
  - **해결**: 알림은 1개 연결만 사용, HTTP/2 사용 시 제한 완화
- **단방향 통신**: 클라이언트 → 서버 메시지 불가
  - **해결**: 읽음 처리 등은 별도 HTTP API 사용

#### WebSocket 대비 장점
- notification 모듈이 live-streaming 모듈의 WebSocket 설정에 의존하지 않음
- STOMP 프로토콜 불필요 (알림은 양방향 통신 필요 없음)
- 연결 관리가 더 단순함

### 3.3 WebPush 선택 이유

#### 장점
- 브라우저 닫혀있을 때 유일한 푸시 방법
- 네이티브 OS 알림 UI 활용
- 표준 Web Push API 사용

#### 요구사항
- **HTTPS 필수**: 보안상 필수
- **VAPID 키**: 서버 식별을 위한 키 쌍 필요
- **사용자 동의**: 브라우저 알림 권한 필요

---

## 4. 아키텍처 설계

### 4.1 모듈 배치 결정

#### SSE 관련 컴포넌트 위치
**SseEmitterManager와 관련 DTO는 api 모듈에 배치**

**이유:**
- `SseEmitter`는 `spring-boot-starter-web`의 클래스로, 웹 레이어 의존성
- notification 모듈은 core 레이어로 웹 의존성을 갖지 않음
- 레이어 분리 원칙 준수: 웹 관련 기술은 api 모듈에 위치

**구조:**
```
api/
└── notification/
    ├── NotificationController (알림 조회 + SSE 연결 엔드포인트)
    └── sse/
        ├── SseEmitterManager (SSE 연결 관리)
        └── NotificationSseDto (SSE 전송용 DTO)

notification/
├── service/
│   └── NotificationPushService (SSE/WebPush 분기 로직)
└── domain/
    └── Notification (엔티티)
```

**의존성 방향:**
```
api (SseEmitterManager)
  ↓ 의존
notification (NotificationPushService, Notification)
```

### 4.2 전체 플로우

```
┌─────────────────────────────────────────────────────────────────┐
│                         알림 생성 이벤트                           │
│              (예: LiveStreamingStartedEvent)                     │
└──────────────────────┬──────────────────────────────────────────┘
                       │
                       ▼
         ┌─────────────────────────────┐
         │  NotificationEventListener  │
         │  (비동기 처리)                │
         └─────────────┬───────────────┘
                       │
                       ▼
         ┌─────────────────────────────┐
         │  Notification 엔티티 생성    │
         │  (DB 저장)                   │
         └─────────────┬───────────────┘
                       │
                       ▼
         ┌─────────────────────────────┐
         │  NotificationPushService    │
         │  (푸시 전송 분기)            │
         └─────────────┬───────────────┘
                       │
         ┌─────────────┴───────────────┐
         │                             │
         ▼                             ▼
┌─────────────────┐          ┌─────────────────┐
│ SSE 연결 확인    │          │ WebPush 전송     │
│ (브라우저 열림)  │          │ (브라우저 닫힘)  │
└────────┬────────┘          └────────┬────────┘
         │                             │
         ▼                             ▼
┌─────────────────┐          ┌─────────────────┐
│ SseEmitter로    │          │ Push Service로  │
│ 실시간 전송      │          │ 전송 (FCM 등)   │
└─────────────────┘          └─────────────────┘
```

### 4.3 컴포넌트 구조

```
api/
└── notification/
    ├── NotificationController
    │   ├── GET /api/v1/notifications (알림 목록)
    │   └── GET /api/v1/notifications/stream (SSE 연결)
    └── sse/
        ├── SseEmitterManager (SSE 연결 관리)
        └── NotificationSseDto (SSE 전송용 DTO)

notification/
├── service/
│   ├── NotificationQueryService (기존)
│   ├── NotificationReadService (신규)
│   │   └── 읽음 처리 로직
│   ├── WebPushService (신규)
│   │   ├── Push 전송
│   │   └── 만료 구독 정리
│   └── NotificationPushService (신규)
│       └── SSE/WebPush 분기 로직
│
├── domain/
│   ├── Notification (기존)
│   ├── PushSubscription (신규 엔티티)
│   ├── NotificationReader (기존)
│   ├── NotificationWriter (기존)
│   ├── PushSubscriptionReader (신규)
│   └── PushSubscriptionWriter (신규)
│
├── repository/
│   ├── NotificationRepository (기존)
│   └── PushSubscriptionRepository (신규)
│
├── event/
│   └── NotificationEventListener (수정)
│       └── 푸시 전송 로직 추가
│
└── config/
    └── WebPushConfig (신규)
        └── VAPID 키 설정
```

---

## 4. Database 스키마 설계

### 4.1 기존 테이블: `notification`

변경사항 없음. 기존 구조 유지.

```sql
CREATE TABLE notification (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    receiver_id BIGINT NOT NULL,
    notification_type VARCHAR(255) NOT NULL,
    target_type VARCHAR(255) NOT NULL,
    target_id BIGINT,
    title VARCHAR(255),
    thumbnail_url VARCHAR(255),
    deeplink_url VARCHAR(255),
    is_read BOOLEAN NOT NULL DEFAULT FALSE,
    read_at TIMESTAMP,
    created_date TIMESTAMP,
    updated_date TIMESTAMP,
    FOREIGN KEY (receiver_id) REFERENCES user(id),
    INDEX idx_notification_receiver_created (receiver_id, created_date DESC),
    INDEX idx_notification_receiver_read (receiver_id, is_read)
);
```

**추가 인덱스 고려**:
- `idx_notification_receiver_read`: 읽지 않은 알림 개수 조회 최적화

### 4.2 신규 테이블: `push_subscription`

WebPush 구독 정보 저장.

```sql
CREATE TABLE push_subscription (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_id BIGINT NOT NULL,
    endpoint VARCHAR(500) NOT NULL,
    p256dh VARCHAR(255) NOT NULL,
    auth VARCHAR(255) NOT NULL,
    user_agent VARCHAR(500),
    created_date TIMESTAMP,
    updated_date TIMESTAMP,
    last_used_date TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id),
    UNIQUE KEY uk_endpoint (endpoint),
    INDEX idx_push_user (user_id)
);
```

**필드 설명**:
- `endpoint`: Push Service URL (FCM, APNs 등)
- `p256dh`: Public key (암호화용)
- `auth`: Auth secret (암호화용)
- `user_agent`: 디바이스 식별용 (선택)
- `last_used_date`: 만료 구독 정리용

**사용자당 여러 디바이스 지원**:
- `user_id`에 UNIQUE 제약조건 없음 → 1:N 관계
- `endpoint`에 UNIQUE 제약조건 → 중복 구독 방지

---

## 5. SSE (Server-Sent Events) 구현 설계

### 5.1 SSE 연결 관리

#### SseEmitter 저장소
- 사용자별 SSE 연결을 메모리에 관리
- `ConcurrentHashMap<Long, List<SseEmitter>>` 구조
  - Key: userId
  - Value: SseEmitter 리스트 (여러 탭/브라우저 지원)

#### 연결 흐름
```
1. 클라이언트: GET /api/v1/notifications/stream
2. 서버: SseEmitter 생성 (타임아웃: 30분)
3. 서버: 초기 연결 이벤트 전송 (heartbeat)
4. 서버: userId별 Map에 SseEmitter 저장
5. 클라이언트: EventSource로 연결 유지
```

#### 연결 종료 처리
- `onCompletion`: 정상 종료 시 Map에서 제거
- `onTimeout`: 타임아웃 시 Map에서 제거
- `onError`: 에러 시 Map에서 제거 및 로깅

### 5.2 SSE 이벤트 타입

클라이언트가 받을 이벤트 유형:

```typescript
// 1. 새 알림
{
  "event": "notification",
  "data": {
    "id": 123,
    "targetType": "LIVE_STREAMING",
    "title": "채널명 실시간 스트리밍 중: 제목",
    "thumbnailUrl": "https://...",
    "deeplinkUrl": "/lives/456",
    "createdDate": "2025-11-22T10:00:00Z"
  }
}

// 2. 읽지 않은 알림 개수
{
  "event": "unread-count",
  "data": {
    "count": 5
  }
}

// 3. Heartbeat (연결 유지)
{
  "event": "heartbeat",
  "data": "ping"
}
```

### 5.3 재연결 전략

#### 브라우저 자동 재연결
- SSE는 브라우저가 자동으로 재연결 시도
- Last-Event-ID 헤더로 마지막 이벤트 추적 가능

#### 서버 측 타임아웃
- 30분 타임아웃 설정
- 주기적 heartbeat 전송 (5분마다)으로 연결 유지

---

## 6. WebPush 구현 설계

### 6.1 VAPID 키 설정

#### VAPID란?
- Voluntary Application Server Identification
- 서버를 식별하는 키 쌍 (공개키/비밀키)
- Push Service가 서버를 인증하는 데 사용

#### 키 생성 및 관리
- 서버 시작 시 `application.yml`에서 로드
- 없으면 새로 생성 후 로그 출력 (운영 환경에서는 고정)

```yaml
webpush:
  vapid:
    public-key: "BK..."
    private-key: "..."
    subject: "mailto:admin@youtube-clone.com"
```

### 6.2 구독 플로우

```
1. 프론트엔드: Service Worker 등록
2. 프론트엔드: Push Manager에서 구독 생성
   - VAPID 공개키 사용
3. 프론트엔드: 구독 정보를 백엔드로 전송
   POST /api/v1/push/subscribe
   {
     "endpoint": "https://fcm.googleapis.com/...",
     "keys": {
       "p256dh": "...",
       "auth": "..."
     }
   }
4. 백엔드: PushSubscription 엔티티 생성 및 저장
   - 중복 체크 (endpoint 기준)
   - 사용자당 여러 구독 허용
```

### 6.3 Push 전송 플로우

```
1. 알림 생성 이벤트 발생
2. NotificationPushService: SSE 연결 확인
   - SSE 연결 있음 → SSE로 전송
   - SSE 연결 없음 → WebPush로 전송
3. WebPushService: 사용자의 모든 구독 조회
4. 각 구독에 대해 Push Service로 전송
   - VAPID 서명 생성
   - HTTP POST to endpoint
5. 실패 처리
   - 410 Gone / 404 Not Found → 구독 삭제
   - 기타 에러 → 로깅 및 재시도 (선택)
```

### 6.4 Push 메시지 포맷

```json
{
  "notification": {
    "title": "채널명 실시간 스트리밍 중",
    "body": "스트리밍 제목",
    "icon": "https://...썸네일",
    "badge": "/badge-icon.png",
    "data": {
      "url": "/lives/456",
      "notificationId": 123
    },
    "actions": [
      {
        "action": "open",
        "title": "보러 가기"
      }
    ]
  }
}
```

### 6.5 만료 구독 정리

#### 정리 기준
- Push 전송 시 410/404 응답 받은 구독
- `last_used_date`가 30일 이상 지난 구독

#### 정리 방법
- 스케줄러 (매일 새벽 3시)
- 배치 DELETE 쿼리

---

## 7. HTTP API 설계

### 7.1 읽음 처리 API

#### Endpoint
```
POST /api/v1/notifications/read
```

#### 요청
```json
{
  "notificationIds": [1, 2, 3, 4, 5]
}
```

또는 전체 읽음 처리:
```json
{
  "markAllAsRead": true
}
```

#### 응답
```json
{
  "updatedCount": 5
}
```

#### 비즈니스 로직
1. 세션에서 userId 추출
2. `notificationIds` 제공 시:
   - 해당 ID들의 알림만 읽음 처리
   - receiver_id = userId 확인 (권한 체크)
3. `markAllAsRead=true` 시:
   - 해당 사용자의 모든 읽지 않은 알림 읽음 처리
4. `is_read=true`, `read_at=CURRENT_TIMESTAMP` 업데이트
5. 읽음 처리된 개수 반환

### 7.2 읽지 않은 알림 개수 조회 API

#### Endpoint
```
GET /api/v1/notifications/unread-count
```

#### 응답
```json
{
  "count": 7
}
```

#### 비즈니스 로직
1. 세션에서 userId 추출
2. `SELECT COUNT(*) FROM notification WHERE receiver_id = ? AND is_read = false`
3. 개수 반환

#### 성능 최적화
- 인덱스 활용: `idx_notification_receiver_read`
- 캐싱 고려 (선택):
  - Redis에 `unread_count:{userId}` 저장
  - 알림 생성/읽음 처리 시 증감
  - TTL: 5분

### 7.3 SSE 연결 API

#### Endpoint
```
GET /api/v1/notifications/stream
```

#### 헤더
```
Accept: text/event-stream
Cache-Control: no-cache
```

#### 응답
```
HTTP/1.1 200 OK
Content-Type: text/event-stream
Cache-Control: no-cache
Connection: keep-alive

event: heartbeat
data: ping

event: notification
data: {"id":123,"title":"..."}

event: unread-count
data: {"count":5}
```

### 7.4 WebPush 구독 API

#### 구독
```
POST /api/v1/push/subscribe
```

**요청**:
```json
{
  "endpoint": "https://fcm.googleapis.com/fcm/send/...",
  "keys": {
    "p256dh": "BL...",
    "auth": "..."
  }
}
```

**응답**:
```json
{
  "subscribed": true
}
```

#### 구독 해지
```
DELETE /api/v1/push/unsubscribe
```

**요청**:
```json
{
  "endpoint": "https://fcm.googleapis.com/fcm/send/..."
}
```

**응답**:
```json
{
  "unsubscribed": true
}
```

---

## 8. 시나리오별 플로우

### 8.1 시나리오 1: 브라우저 열려있고 알림 센터 닫힌 상태

```
[라이브 스트리밍 시작]
        ↓
[LiveStreamingStartedEvent 발행]
        ↓
[NotificationEventListener (비동기)]
        ↓
[Notification 엔티티 생성 및 저장]
        ↓
[NotificationPushService]
        ↓
[SSE 연결 확인] → 연결 있음
        ↓
[SseEmitter로 전송]
  - event: notification (알림 내용)
  - event: unread-count (개수 증가)
        ↓
[클라이언트]
  - 종 아이콘 뱃지 숫자 업데이트 (예: 3 → 4)
  - 알림 센터는 닫혀있으므로 목록 업데이트 안 함
```

### 8.2 시나리오 2: 브라우저 열려있고 알림 센터 열린 상태

```
[라이브 스트리밍 시작]
        ↓
[LiveStreamingStartedEvent 발행]
        ↓
[NotificationEventListener (비동기)]
        ↓
[Notification 엔티티 생성 및 저장]
        ↓
[NotificationPushService]
        ↓
[SSE 연결 확인] → 연결 있음
        ↓
[SseEmitter로 전송]
  - event: notification (알림 내용)
  - event: unread-count (개수 증가)
        ↓
[클라이언트]
  - 종 아이콘 뱃지 숫자 업데이트 (예: 3 → 4)
  - 알림 센터가 열려있으므로 새 알림을 목록 맨 위에 추가
  - 부드러운 애니메이션과 함께 표시
```

### 8.3 시나리오 3: 브라우저 닫혀있음

```
[라이브 스트리밍 시작]
        ↓
[LiveStreamingStartedEvent 발행]
        ↓
[NotificationEventListener (비동기)]
        ↓
[Notification 엔티티 생성 및 저장]
        ↓
[NotificationPushService]
        ↓
[SSE 연결 확인] → 연결 없음
        ↓
[WebPushService]
        ↓
[사용자의 모든 PushSubscription 조회]
        ↓
[각 구독에 Push 전송]
  - VAPID 서명 생성
  - HTTP POST to endpoint
        ↓
[브라우저/OS]
  - 네이티브 알림 표시
  - "채널명 실시간 스트리밍 중: 제목"
  - 클릭 시 해당 URL로 이동
```

### 8.4 시나리오 4: 알림 센터 열기

```
[사용자: 알림 센터 클릭]
        ↓
[프론트엔드]
  1. GET /api/v1/notifications?cursor=null
     - 알림 목록 조회 (읽은 것 포함)
  2. 화면에 알림 목록 렌더링
        ↓
  3. POST /api/v1/notifications/read
     {
       "markAllAsRead": true
     }
     - 모든 알림 읽음 처리
        ↓
[백엔드]
  - Notification.is_read = true 업데이트
  - Notification.read_at = CURRENT_TIMESTAMP 업데이트
        ↓
[프론트엔드]
  - 종 아이콘 뱃지 숫자 0으로 업데이트
```

### 8.5 시나리오 5: 여러 탭/디바이스

```
[사용자: 2개 탭에서 로그인]
        ↓
[각 탭: SSE 연결 생성]
  - Tab 1: SseEmitter #1
  - Tab 2: SseEmitter #2
  - SseEmitterMap: {userId: [emitter1, emitter2]}
        ↓
[알림 생성]
        ↓
[NotificationSseService]
  - userId의 모든 SseEmitter에 전송
  - Tab 1과 Tab 2 모두에 전송
        ↓
[각 탭]
  - 종 아이콘 뱃지 동시 업데이트
  - 열려있는 알림 센터에 알림 추가
```

---

## 9. 보안 고려사항

### 9.1 인증 및 권한

#### SSE 연결
- **세션 기반 인증**: 기존 세션 쿠키 사용
- **연결 시 userId 추출**: 인증되지 않은 사용자는 연결 거부

#### API 권한
- **알림 조회**: 본인의 알림만 조회 가능
- **읽음 처리**: 본인의 알림만 읽음 처리 가능
- **WebPush 구독**: 본인의 디바이스만 등록 가능

#### 구현 방법
- `@LoginRequired` 어노테이션 사용 (기존 방식)
- 세션에서 userId 추출하여 권한 검증

### 9.2 CSRF (Cross-Site Request Forgery) 방어

#### SSE 연결
- GET 요청이므로 상태 변경 없음 → CSRF 위험 낮음
- 세션 쿠키로 인증하므로 SameSite 설정 확인

#### POST/DELETE API
- Spring Security CSRF 토큰 사용
- 프론트엔드: CSRF 토큰을 헤더에 포함

### 9.3 데이터 보호

#### 민감 정보
- WebPush 구독의 `endpoint`, `p256dh`, `auth`는 민감 정보
- HTTPS 필수 (평문 전송 금지)

#### SQL Injection 방지
- JPA/QueryDSL 사용으로 자동 방어
- 사용자 입력은 파라미터 바인딩

### 9.4 Rate Limiting

#### SSE 연결
- 사용자당 최대 5개 연결 제한 (여러 탭/디바이스 고려)
- 초과 시 가장 오래된 연결 종료

#### API 호출
- `/api/v1/push/subscribe`: 분당 10회 제한
- `/api/v1/notifications/read`: 분당 30회 제한

---

## 10. 성능 고려사항

### 10.1 SSE 연결 관리

#### 메모리 사용량
- SseEmitter는 메모리에 저장
- 예상 동시 접속자 10,000명
- SseEmitter당 약 1KB → 총 10MB (무시 가능)

#### 확장성
- 서버가 여러 대일 경우:
  - 문제: 사용자가 연결된 서버로만 SSE 전송 가능
  - 해결 방안:
    1. **Redis Pub/Sub** 사용
       - 알림 생성 시 Redis 채널에 발행
       - 모든 서버가 구독하여 자신의 SSE 연결에 전송
    2. **Sticky Session** 사용
       - 로드 밸런서에서 같은 사용자는 같은 서버로 라우팅

### 10.2 데이터베이스 최적화

#### 인덱스 전략
```sql
-- 읽지 않은 알림 개수 조회
INDEX idx_notification_receiver_read (receiver_id, is_read)

-- 알림 목록 조회 (커서 기반 페이징)
INDEX idx_notification_receiver_created (receiver_id, created_date DESC)

-- WebPush 구독 조회
INDEX idx_push_user (user_id)
```

#### 쿼리 최적화
- **읽지 않은 개수**: COUNT 쿼리 캐싱 고려
  - Redis: `unread_count:{userId}`
  - TTL: 5분
  - 알림 생성/읽음 처리 시 캐시 무효화

- **알림 목록**: 커서 기반 페이징으로 OFFSET 회피

#### 대량 업데이트 최적화
- 읽음 처리 API (markAllAsRead):
  ```sql
  UPDATE notification
  SET is_read = true, read_at = CURRENT_TIMESTAMP
  WHERE receiver_id = ? AND is_read = false
  ```
  - 인덱스 활용으로 빠른 처리

### 10.3 비동기 처리

#### 알림 생성
- 이미 `@Async`로 비동기 처리 중
- 전용 스레드 풀 설정 (issue-solution-docs 참고):
  - CorePoolSize: 5
  - MaxPoolSize: 10
  - QueueCapacity: 100

#### WebPush 전송
- 알림 생성과 별도 스레드 풀 고려
  - `webPushTaskExecutor`
  - CorePoolSize: 10 (외부 API 호출이 많음)

### 10.4 캐싱 전략

#### 읽지 않은 알림 개수
```java
@Cacheable(value = "unreadCount", key = "#userId")
public int getUnreadCount(Long userId) { ... }

@CacheEvict(value = "unreadCount", key = "#userId")
public void markAsRead(Long userId, List<Long> ids) { ... }
```

#### 캐시 저장소
- 로컬 캐시 (Caffeine): 단일 서버 환경
- Redis: 다중 서버 환경

---

## 11. 에러 처리 및 로깅

### 11.1 SSE 에러 처리

#### 클라이언트 에러
```java
sseEmitter.onError(throwable -> {
    log.warn("SSE 연결 에러 - userId: {}, error: {}",
        userId, throwable.getMessage());
    removeSseEmitter(userId, sseEmitter);
});
```

#### 타임아웃
```java
sseEmitter.onTimeout(() -> {
    log.debug("SSE 연결 타임아웃 - userId: {}", userId);
    removeSseEmitter(userId, sseEmitter);
});
```

#### 전송 실패
- SseEmitter.send() 실패 시 해당 연결 제거
- 다른 연결들은 정상 전송 계속

### 11.2 WebPush 에러 처리

#### 구독 만료
```java
if (response.getStatusCode() == 410 || response.getStatusCode() == 404) {
    log.info("WebPush 구독 만료 - subscriptionId: {}", subscriptionId);
    pushSubscriptionWriter.delete(subscriptionId);
}
```

#### 전송 실패
```java
catch (Exception e) {
    log.error("WebPush 전송 실패 - userId: {}, subscriptionId: {}, error: {}",
        userId, subscriptionId, e.getMessage());
    // 재시도는 하지 않음 (알림은 실시간성이 중요)
}
```

### 11.3 로깅 전략

#### INFO 레벨
```java
log.info("SSE 연결 생성 - userId: {}", userId);
log.info("알림 전송 성공 - userId: {}, notificationId: {}, channel: {}",
    userId, notificationId, channel); // channel: SSE or WebPush
log.info("WebPush 구독 등록 - userId: {}, endpoint: {}", userId, endpoint);
```

#### WARN 레벨
```java
log.warn("SSE 연결 제한 초과 - userId: {}, currentCount: {}",
    userId, currentCount);
log.warn("WebPush 전송 실패 (재시도 안 함) - userId: {}", userId);
```

#### ERROR 레벨
```java
log.error("알림 생성 실패 - liveStreamingId: {}, error: {}",
    liveStreamingId, e.getMessage(), e);
```

---

## 12. 테스트 전략

### 12.1 단위 테스트

#### NotificationSseService
- **테스트 대상**:
  - SSE 연결 추가/제거
  - 알림 전송 (성공/실패)
  - 연결 제한 검증
- **Mocking**: SseEmitter 동작

#### WebPushService
- **테스트 대상**:
  - Push 전송 로직
  - 만료 구독 삭제
  - VAPID 서명 생성
- **Mocking**: HTTP 클라이언트

#### NotificationPushService
- **테스트 대상**:
  - SSE/WebPush 분기 로직
- **Mocking**: NotificationSseService, WebPushService

### 12.2 통합 테스트

#### SSE 연결 테스트
```java
@Test
@DisplayName("SSE 연결 생성 후 알림 전송 시 실시간으로 수신된다")
void sseNotificationReceived() {
    // given: 사용자 로그인 및 SSE 연결
    // when: 알림 생성
    // then: SSE로 알림 수신 확인
}
```

#### 읽음 처리 테스트
```java
@Test
@DisplayName("알림 센터를 열면 모든 알림이 읽음 처리된다")
void markAllAsReadWhenOpenNotificationCenter() {
    // given: 사용자에게 읽지 않은 알림 5개
    // when: POST /api/v1/notifications/read (markAllAsRead=true)
    // then: 모든 알림의 is_read=true, 개수=0
}
```

#### WebPush 구독 테스트
```java
@Test
@DisplayName("WebPush 구독 등록 시 DB에 저장된다")
void subscribeWebPush() {
    // given: 사용자 로그인
    // when: POST /api/v1/push/subscribe
    // then: PushSubscription 엔티티 생성 확인
}
```

### 12.3 부하 테스트 (선택)

#### 시나리오
- 동시 접속자 10,000명 SSE 연결
- 알림 생성 시 10,000개 SSE 전송 성능
- WebPush 대량 전송 (1,000개)

#### 도구
- JMeter 또는 Gatling

---

## 13. 배포 및 운영

### 13.1 환경 설정

#### application.yml
```yaml
webpush:
  vapid:
    public-key: ${VAPID_PUBLIC_KEY}
    private-key: ${VAPID_PRIVATE_KEY}
    subject: ${VAPID_SUBJECT:mailto:admin@youtube-clone.com}

sse:
  timeout: ${SSE_TIMEOUT:1800000} # 30분 (밀리초)
  heartbeat-interval: ${SSE_HEARTBEAT_INTERVAL:300000} # 5분

notification:
  push:
    retry-count: ${PUSH_RETRY_COUNT:0} # 재시도 안 함
```

#### 환경 변수
- `VAPID_PUBLIC_KEY`: WebPush VAPID 공개키
- `VAPID_PRIVATE_KEY`: WebPush VAPID 비밀키
- `VAPID_SUBJECT`: 연락처 (mailto:...)

### 13.2 모니터링

#### 메트릭
- **SSE 연결 수**: 현재 활성 SSE 연결 수 (userId별)
- **알림 전송 성공/실패 수**: SSE, WebPush 각각
- **WebPush 구독 수**: 활성 구독 수
- **읽지 않은 알림 개수 분포**: 평균, 최대값

#### 로그 분석
- 알림 생성 → 전송까지 소요 시간
- SSE 연결 에러율
- WebPush 전송 실패율

#### 알람
- SSE 연결 에러율 > 5%
- WebPush 전송 실패율 > 10%
- 알림 생성 후 10초 이내 전송 실패

### 13.3 데이터 정리

#### 스케줄러 설정
```java
@Scheduled(cron = "0 0 3 * * *") // 매일 새벽 3시
public void cleanupExpiredSubscriptions() {
    // last_used_date가 30일 이상 지난 구독 삭제
}

@Scheduled(cron = "0 0 4 * * *") // 매일 새벽 4시
public void cleanupOldNotifications() {
    // 5주 이상 지난 알림 삭제 (NotificationPolicy)
}
```

---

## 14. 프론트엔드 가이드

### 14.1 SSE 연결

#### JavaScript (EventSource)
```javascript
const eventSource = new EventSource('/api/v1/notifications/stream');

// 알림 수신
eventSource.addEventListener('notification', (event) => {
  const notification = JSON.parse(event.data);
  // 알림 센터가 열려있으면 목록에 추가
  // 종 아이콘 뱃지 업데이트는 unread-count 이벤트에서 처리
});

// 읽지 않은 개수 업데이트
eventSource.addEventListener('unread-count', (event) => {
  const { count } = JSON.parse(event.data);
  updateBadge(count); // 종 아이콘 뱃지 업데이트
});

// 에러 처리
eventSource.onerror = (error) => {
  console.error('SSE 연결 에러:', error);
  // 브라우저가 자동으로 재연결 시도
};
```

### 14.2 WebPush 구독

#### Service Worker 등록
```javascript
// service-worker.js
self.addEventListener('push', (event) => {
  const data = event.data.json();
  const options = {
    body: data.notification.body,
    icon: data.notification.icon,
    badge: data.notification.badge,
    data: data.notification.data
  };

  event.waitUntil(
    self.registration.showNotification(data.notification.title, options)
  );
});

self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  event.waitUntil(
    clients.openWindow(event.notification.data.url)
  );
});
```

#### 구독 요청
```javascript
// 1. Service Worker 등록
navigator.serviceWorker.register('/service-worker.js');

// 2. Push 권한 요청
const permission = await Notification.requestPermission();
if (permission !== 'granted') {
  return;
}

// 3. Push Manager에서 구독 생성
const registration = await navigator.serviceWorker.ready;
const subscription = await registration.pushManager.subscribe({
  userVisibleOnly: true,
  applicationServerKey: urlBase64ToUint8Array(VAPID_PUBLIC_KEY)
});

// 4. 백엔드로 구독 정보 전송
await fetch('/api/v1/push/subscribe', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify(subscription)
});
```

### 14.3 알림 센터 열기

```javascript
async function openNotificationCenter() {
  // 1. 알림 목록 조회
  const response = await fetch('/api/v1/notifications?cursor=null');
  const data = await response.json();
  renderNotifications(data.notifications);

  // 2. 모든 알림 읽음 처리
  await fetch('/api/v1/notifications/read', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ markAllAsRead: true })
  });

  // 3. 종 아이콘 뱃지 0으로 업데이트
  updateBadge(0);
}
```

---

## 15. 향후 확장 가능성

### 15.1 다중 서버 환경 지원

#### Redis Pub/Sub
```
[서버 1, 2, 3] → [Redis Pub/Sub] → [서버 1, 2, 3]
                     ↓
              모든 서버가 구독
                     ↓
           자신의 SSE 연결에 전송
```

#### 구현 변경사항
- NotificationSseService: Redis 메시지 리스너 추가
- 알림 생성 시 Redis 채널에 발행

### 15.2 알림 타입 확장

현재는 `LIVE_STREAMING_STARTED`만 지원하지만, 향후 추가 가능:

- `VIDEO_COMMENT`: 동영상에 댓글 달림
- `COMMENT_REPLY`: 내 댓글에 답글 달림
- `VIDEO_LIKE`: 내 동영상에 좋아요
- `NEW_SUBSCRIBER`: 새 구독자 등록

### 15.3 알림 설정 기능

사용자가 알림 타입별로 수신 여부 설정:

```sql
CREATE TABLE notification_setting (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_id BIGINT NOT NULL,
    notification_type VARCHAR(255) NOT NULL,
    enabled BOOLEAN NOT NULL DEFAULT TRUE,
    UNIQUE KEY uk_user_type (user_id, notification_type)
);
```

### 15.4 알림 우선순위

```java
enum NotificationPriority {
    HIGH,    // 즉시 전송
    MEDIUM,  // 1분 이내 전송
    LOW      // 배치 전송 (예: 10분마다)
}
```

### 15.5 알림 그룹화

같은 타입의 알림을 그룹화하여 표시:

```
"3명이 회원님의 동영상에 좋아요를 눌렀습니다"
```

---

## 16. 참고 자료

### 16.1 기술 문서

- **SSE**: https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events
- **Web Push API**: https://developer.mozilla.org/en-US/docs/Web/API/Push_API
- **VAPID**: https://datatracker.ietf.org/doc/html/rfc8292
- **Spring SseEmitter**: https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-ann-async.html#mvc-ann-async-sse

### 16.2 라이브러리

- **Web Push (Java)**: https://github.com/web-push-libs/webpush-java
  ```gradle
  implementation 'nl.martijndwars:web-push:5.1.1'
  ```

---

## 17. 체크리스트

### 17.1 구현 체크리스트

#### Database
- [ ] `push_subscription` 테이블 생성
- [ ] `notification` 테이블 인덱스 추가
- [ ] 마이그레이션 스크립트 작성 (선택)

#### SSE
- [x] SSE 연결 엔드포인트 구현 (NotificationController - `/stream`)
- [x] SseEmitterManager 구현 (연결 관리)
- [x] SSE 이벤트 전송 로직
- [ ] Heartbeat 스케줄러
- [ ] 연결 제한 로직

#### WebPush
- [ ] PushSubscription 엔티티 및 Repository
- [ ] PushSubscriptionController 구현
- [ ] WebPushService 구현 (전송 로직)
- [ ] WebPushConfig (VAPID 설정)
- [ ] 만료 구독 정리 스케줄러

#### HTTP API
- [ ] 읽음 처리 API 구현
- [ ] 읽지 않은 개수 조회 API

#### 통합
- [x] NotificationEventListener 수정 (알림 생성 후 NotificationCreatedEvent 발행)
- [x] NotificationPushEventListener 구현 (SSE/WebPush 분기 - SSE만 구현됨)
- [x] NotificationCreatedEvent 생성
- [ ] WebPush 전송 로직 구현 (TODO 상태)

#### 테스트
- [x] SseEmitterManager 단위 테스트 (동시성 테스트 포함)
- [ ] NotificationController SSE 통합 테스트
- [ ] WebPush 구독 및 전송 테스트 (Mock)
- [ ] 읽음 처리 통합 테스트
- [ ] 시나리오 기반 E2E 테스트

### 17.2 배포 체크리스트

- [ ] VAPID 키 생성 및 환경 변수 설정
- [ ] HTTPS 설정 확인
- [ ] 프론트엔드 Service Worker 배포
- [ ] 모니터링 대시보드 설정
- [ ] 알람 설정
- [ ] 성능 테스트 (부하 테스트)

---

## 18. 결론

HTTP/SSE/WebPush 조합은 알림 푸시 기능 구현에 최적의 선택입니다. 각 기술이 명확한 역할을 가지며, notification 모듈이 독립적으로 운영될 수 있습니다.

### 핵심 설계 원칙
1. **역할 분리**: HTTP (CRUD), SSE (실시간), WebPush (오프라인)
2. **사용자 경험**: 브라우저 상태에 따른 적절한 알림 전달
3. **성능**: 비동기 처리, 인덱스 최적화, 캐싱
4. **확장성**: 다중 서버 환경 고려 (Redis Pub/Sub)
5. **보안**: 인증, 권한, HTTPS, Rate Limiting

### 다음 단계
1. Database 스키마 생성
2. SSE 기본 구조 구현 및 테스트
3. WebPush 구독 및 전송 구현
4. 통합 및 E2E 테스트
5. 프론트엔드 연동
6. 배포 및 모니터링